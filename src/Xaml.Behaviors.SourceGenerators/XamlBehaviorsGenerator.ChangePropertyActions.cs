// Copyright (c) Wiesław Šoltés. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.

using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Xaml.Behaviors.SourceGenerators
{
    public partial class XamlBehaviorsGenerator
    {
        private record ChangePropertyInfo(
            string? Namespace,
            string ClassName,
            string Accessibility,
            string TargetTypeName,
            string PropertyName,
            string PropertyType,
            bool UseDispatcher,
            Diagnostic? Diagnostic = null);

        private void RegisterChangePropertyActionGeneration(IncrementalGeneratorInitializationContext context)
        {
            var propertyActions = context.SyntaxProvider
                .ForAttributeWithMetadataName(
                    GenerateTypedChangePropertyActionAttributeName,
                    predicate: static (_, _) => true,
                    transform: (ctx, _) => GetChangePropertyActionToGenerate(ctx))
                .SelectMany((x, _) => x);

            var assemblyPropertyActions = context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: static (node, _) => IsAssemblyAttribute(node, "GenerateTypedChangePropertyAction"),
                    transform: (ctx, _) => GetAssemblyChangePropertyFromAttributeSyntax(ctx))
                .SelectMany((info, _) => info);

            var uniquePropertyActions = propertyActions
                .Collect()
                .Combine(assemblyPropertyActions.Collect())
                .SelectMany((data, _) => EnsureUniqueChangePropertyActions(data.Left.Concat(data.Right)));

            context.RegisterSourceOutput(uniquePropertyActions, ExecuteGenerateChangePropertyAction);
        }

        private ImmutableArray<ChangePropertyInfo> GetChangePropertyActionToGenerate(GeneratorAttributeSyntaxContext context)
        {
            var results = ImmutableArray.CreateBuilder<ChangePropertyInfo>();
            var symbol = context.TargetSymbol;
            if (symbol is IAssemblySymbol)
            {
                return results.ToImmutable();
            }

            if (symbol is IPropertySymbol propertySymbol)
            {
                var diagnosticLocation = context.TargetNode?.GetLocation() ?? Location.None;
                var containingType = propertySymbol.ContainingType;
                if (containingType != null)
                {
                    foreach (var attribute in context.Attributes)
                    {
                        var useDispatcher = GetUseDispatcherFlag(attribute, context.SemanticModel);
                        var location = attribute.ApplicationSyntaxReference?.GetSyntax()?.GetLocation() ?? diagnosticLocation;
                        results.Add(CreateChangePropertyInfo(containingType, propertySymbol, location, includeTypeNamePrefix: false, compilation: context.SemanticModel.Compilation, useDispatcher: useDispatcher));
                    }
                }
            }
            return results.ToImmutable();
        }

        private void ExecuteGenerateChangePropertyAction(SourceProductionContext spc, ChangePropertyInfo info)
        {
            if (info.Diagnostic != null)
            {
                spc.ReportDiagnostic(info.Diagnostic);
                return;
            }

            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated />");
            sb.AppendLine("#nullable enable");
            sb.AppendLine("using Avalonia;");
            sb.AppendLine("using Avalonia.Xaml.Interactivity;");
            sb.AppendLine("using Avalonia.Controls;");
            sb.AppendLine("using Avalonia.Threading;");
            sb.AppendLine();
            if (!string.IsNullOrEmpty(info.Namespace))
            {
                sb.AppendLine($"namespace {info.Namespace}");
                sb.AppendLine("{");
            }
            sb.AppendLine($"    {info.Accessibility} partial class {info.ClassName} : Avalonia.Xaml.Interactivity.StyledElementAction");
            sb.AppendLine("    {");
            sb.AppendLine($"        public static readonly StyledProperty<object?> TargetObjectProperty =");
            sb.AppendLine($"            AvaloniaProperty.Register<{info.ClassName}, object?>(nameof(TargetObject));");
            sb.AppendLine();
            sb.AppendLine($"        public static readonly StyledProperty<{info.PropertyType}> ValueProperty =");
            sb.AppendLine($"            AvaloniaProperty.Register<{info.ClassName}, {info.PropertyType}>(nameof(Value));");
            sb.AppendLine();
            sb.AppendLine("        public object? TargetObject");
            sb.AppendLine("        {");
            sb.AppendLine("            get => GetValue(TargetObjectProperty);");
            sb.AppendLine("            set => SetValue(TargetObjectProperty, value);");
            sb.AppendLine("        }");
            sb.AppendLine();
            sb.AppendLine($"        public {info.PropertyType} Value");
            sb.AppendLine("        {");
            sb.AppendLine("            get => GetValue(ValueProperty);");
            sb.AppendLine("            set => SetValue(ValueProperty, value);");
            sb.AppendLine("        }");
            sb.AppendLine();
            sb.AppendLine("        public override object Execute(object? sender, object? parameter)");
            sb.AppendLine("        {");
            sb.AppendLine("            var target = TargetObject ?? sender;");
            sb.AppendLine($"            if (target is {info.TargetTypeName} typedTarget)");
            sb.AppendLine("            {");
            if (info.UseDispatcher)
            {
                sb.AppendLine($"                Avalonia.Threading.Dispatcher.UIThread.Post(() => typedTarget.{info.PropertyName} = Value);");
            }
            else
            {
                sb.AppendLine($"                typedTarget.{info.PropertyName} = Value;");
            }
            sb.AppendLine("                return true;");
            sb.AppendLine("            }");
            sb.AppendLine("            return false;");
            sb.AppendLine("        }");
            sb.AppendLine("    }");
            if (!string.IsNullOrEmpty(info.Namespace))
            {
                sb.AppendLine("}");
            }

            spc.AddSource(CreateHintName(info.Namespace, info.ClassName), SourceText.From(sb.ToString(), Encoding.UTF8));
        }

        private static Diagnostic? ValidatePropertySymbol(IPropertySymbol propertySymbol, Location? diagnosticLocation, Compilation? compilation)
        {
            var location = diagnosticLocation ?? Location.None;

            if (propertySymbol.IsStatic)
            {
                return Diagnostic.Create(StaticMemberNotSupportedDiagnostic, location, propertySymbol.Name);
            }

            var containingTypeDiagnostic = ValidateTypeAccessibility(propertySymbol.ContainingType, location, compilation);
            if (containingTypeDiagnostic != null)
            {
                return containingTypeDiagnostic;
            }

            if (!HasAccessibleSetter(propertySymbol, compilation))
            {
                return Diagnostic.Create(PropertySetterNotAccessibleDiagnostic, location, propertySymbol.Name, propertySymbol.ContainingType.ToDisplayString());
            }

            if (propertySymbol.SetMethod?.IsInitOnly == true)
            {
                return Diagnostic.Create(InitOnlySetterNotSupportedDiagnostic, location, propertySymbol.Name, propertySymbol.ContainingType.ToDisplayString());
            }

            if (ContainsTypeParameter(propertySymbol.ContainingType) || ContainsTypeParameter(propertySymbol.Type))
            {
                return Diagnostic.Create(GenericMemberNotSupportedDiagnostic, location, propertySymbol.Name);
            }

            if (!IsAccessibleType(propertySymbol.Type, compilation))
            {
                return Diagnostic.Create(MemberNotAccessibleDiagnostic, location, propertySymbol.Name, propertySymbol.ContainingType.ToDisplayString());
            }

            return null;
        }

        private ImmutableArray<ChangePropertyInfo> GetAssemblyChangePropertyFromAttributeSyntax(GeneratorSyntaxContext context)
        {
            if (context.Node is not AttributeSyntax attributeSyntax)
                return ImmutableArray<ChangePropertyInfo>.Empty;

            if (attributeSyntax.ArgumentList?.Arguments == null)
                return ImmutableArray<ChangePropertyInfo>.Empty;

            var positionalArguments = attributeSyntax.ArgumentList.Arguments
                .Where(a => a.NameEquals is null && a.NameColon is null)
                .ToList();

            if (positionalArguments.Count < 2)
                return ImmutableArray<ChangePropertyInfo>.Empty;

            if (positionalArguments[0].Expression is not TypeOfExpressionSyntax typeOfExpression)
                return ImmutableArray<ChangePropertyInfo>.Empty;

            if (positionalArguments[1].Expression is not LiteralExpressionSyntax propertyLiteral)
                return ImmutableArray<ChangePropertyInfo>.Empty;

            var useDispatcher = GetBoolNamedArgument(attributeSyntax, context.SemanticModel, "UseDispatcher");

            var propertyName = propertyLiteral.Token.ValueText;
            var targetType = context.SemanticModel.GetTypeInfo(typeOfExpression.Type).Type as INamedTypeSymbol;
            if (targetType == null || string.IsNullOrEmpty(propertyName))
            {
                var diagnostic = Diagnostic.Create(ChangePropertyNotFoundDiagnostic, Location.None, propertyName ?? "<unknown>", targetType?.Name ?? "<unknown>");
                return ImmutableArray.Create(new ChangePropertyInfo("", "", "public", "", propertyName ?? "<unknown>", "", useDispatcher, diagnostic));
            }

            return CreateChangePropertyInfos(targetType, propertyName, context.Node.GetLocation(), includeTypeNamePrefix: true, compilation: context.SemanticModel.Compilation, useDispatcher: useDispatcher);
        }

        private ImmutableArray<ChangePropertyInfo> GetAssemblyChangePropertyActions(Compilation compilation)
        {
            var results = ImmutableArray.CreateBuilder<ChangePropertyInfo>();

            foreach (var attributeData in compilation.Assembly.GetAttributes())
            {
                if (!IsAttribute(attributeData, GenerateTypedChangePropertyActionAttributeName)) continue;
                if (attributeData.ConstructorArguments.Length != 2) continue;

                var targetType = attributeData.ConstructorArguments[0].Value as INamedTypeSymbol;
                var propertyName = attributeData.ConstructorArguments[1].Value as string;
                var useDispatcher = GetBoolNamedArgument(attributeData, "UseDispatcher");

                if (targetType == null || string.IsNullOrEmpty(propertyName))
                {
                    var diagnostic = Diagnostic.Create(ChangePropertyNotFoundDiagnostic, Location.None, propertyName ?? "<unknown>", targetType?.Name ?? "<unknown>");
                    results.Add(new ChangePropertyInfo("", "", "public", "", "", "", useDispatcher, diagnostic));
                    continue;
                }

                results.AddRange(CreateChangePropertyInfos(targetType, propertyName!, Location.None, includeTypeNamePrefix: true, compilation: compilation, useDispatcher: useDispatcher));
            }

            return results.ToImmutable();
        }

        private ImmutableArray<ChangePropertyInfo> CreateChangePropertyInfos(INamedTypeSymbol targetType, string propertyPattern, Location? diagnosticLocation = null, bool includeTypeNamePrefix = false, Compilation? compilation = null, bool useDispatcher = false)
        {
            var matchedProperties = FindMatchingProperties(targetType, propertyPattern);
            var typePrefix = includeTypeNamePrefix ? GetTypeNamePrefix(targetType) : string.Empty;
            if (matchedProperties.Length == 0)
            {
                var diagnostic = Diagnostic.Create(ChangePropertyNotFoundDiagnostic, diagnosticLocation ?? Location.None, propertyPattern, targetType.Name);
                var baseName = $"Set{CreateSafeIdentifier(propertyPattern)}Action";
                var className = string.IsNullOrEmpty(typePrefix) ? baseName : typePrefix + baseName;
                var ns = targetType.ContainingNamespace.ToDisplayString();
                var namespaceName = (targetType.ContainingNamespace.IsGlobalNamespace || ns == "<global namespace>") ? null : ns;
                var targetTypeName = ToDisplayStringWithNullable(targetType);
                var accessibility = GetAccessibilityKeyword(targetType);
                return ImmutableArray.Create(new ChangePropertyInfo(namespaceName, className, accessibility, targetTypeName, propertyPattern, "", useDispatcher, diagnostic));
            }

            var builder = ImmutableArray.CreateBuilder<ChangePropertyInfo>();
            var invalidBuilder = ImmutableArray.CreateBuilder<ChangePropertyInfo>();
            foreach (var property in matchedProperties)
            {
                var info = CreateChangePropertyInfo(targetType, property, diagnosticLocation, includeTypeNamePrefix, compilation, useDispatcher);
                if (info.Diagnostic is null)
                {
                    builder.Add(info);
                }
                else
                {
                    invalidBuilder.Add(info);
                }
            }

            if (builder.Count > 0)
            {
                return builder.ToImmutable();
            }

            if (invalidBuilder.Count > 0)
            {
                return invalidBuilder.ToImmutable();
            }

            var fallback = Diagnostic.Create(ChangePropertyNotFoundDiagnostic, diagnosticLocation ?? Location.None, propertyPattern, targetType.Name);
            var fallbackName = $"Set{CreateSafeIdentifier(propertyPattern)}Action";
            var classNameFallback = string.IsNullOrEmpty(typePrefix) ? fallbackName : typePrefix + fallbackName;
            var nsFallback = targetType.ContainingNamespace.ToDisplayString();
            var namespaceNameFallback = (targetType.ContainingNamespace.IsGlobalNamespace || nsFallback == "<global namespace>") ? null : nsFallback;
            var targetTypeNameFallback = ToDisplayStringWithNullable(targetType);
            var accessibilityFallback = GetAccessibilityKeyword(targetType);
            return ImmutableArray.Create(new ChangePropertyInfo(namespaceNameFallback, classNameFallback, accessibilityFallback, targetTypeNameFallback, propertyPattern, "", useDispatcher, fallback));
        }

        private ChangePropertyInfo CreateChangePropertyInfo(INamedTypeSymbol targetType, IPropertySymbol propertySymbol, Location? diagnosticLocation = null, bool includeTypeNamePrefix = false, Compilation? compilation = null, bool useDispatcher = false)
        {
            if (propertySymbol.IsIndexer)
            {
                var diagnostic = Diagnostic.Create(ChangePropertyNotFoundDiagnostic, diagnosticLocation ?? Location.None, propertySymbol.Name, targetType.Name);
                var nsIndex = targetType.ContainingNamespace.ToDisplayString();
                var namespaceIndex = (targetType.ContainingNamespace.IsGlobalNamespace || nsIndex == "<global namespace>") ? null : nsIndex;
                var baseNameIndex = $"Set{propertySymbol.Name}Action";
                var prefixIndex = includeTypeNamePrefix ? GetTypeNamePrefix(targetType) : string.Empty;
                var classNameIndex = string.IsNullOrEmpty(prefixIndex) ? baseNameIndex : prefixIndex + baseNameIndex;
                var targetTypeNameIndex = ToDisplayStringWithNullable(targetType);
                var accessibilityIndex = GetChangePropertyAccessibility(targetType, propertySymbol);
                return new ChangePropertyInfo(namespaceIndex, classNameIndex, accessibilityIndex, targetTypeNameIndex, propertySymbol.Name, ToDisplayStringWithNullable(propertySymbol.Type), useDispatcher, diagnostic);
            }

            var validationDiagnostic = ValidatePropertySymbol(propertySymbol, diagnosticLocation, compilation);
            var ns = targetType.ContainingNamespace.ToDisplayString();
            var namespaceName = (targetType.ContainingNamespace.IsGlobalNamespace || ns == "<global namespace>") ? null : ns;
            var baseName = $"Set{propertySymbol.Name}Action";
            var typePrefix = includeTypeNamePrefix ? GetTypeNamePrefix(targetType) : string.Empty;
            var className = string.IsNullOrEmpty(typePrefix) ? baseName : typePrefix + baseName;
            var targetTypeName = ToDisplayStringWithNullable(targetType);
            var propertyName = propertySymbol.Name;
            var propertyType = ToDisplayStringWithNullable(propertySymbol.Type);
            var accessibility = GetChangePropertyAccessibility(targetType, propertySymbol);

            if (validationDiagnostic != null)
            {
                return new ChangePropertyInfo(namespaceName, className, accessibility, targetTypeName, propertyName, propertyType, useDispatcher, validationDiagnostic);
            }

            return new ChangePropertyInfo(namespaceName, className, accessibility, targetTypeName, propertyName, propertyType, useDispatcher);
        }

        private ChangePropertyInfo CreateChangePropertyInfo(INamedTypeSymbol targetType, string propertyName, Location? diagnosticLocation = null, bool useDispatcher = false)
        {
            var infos = CreateChangePropertyInfos(targetType, propertyName, diagnosticLocation, useDispatcher: useDispatcher);
            var accessibility = GetAccessibilityKeyword(targetType);
            var targetTypeName = ToDisplayStringWithNullable(targetType);
            return infos.Length > 0 ? infos[0] : new ChangePropertyInfo("", "", accessibility, targetTypeName, propertyName, "", useDispatcher, Diagnostic.Create(ChangePropertyNotFoundDiagnostic, diagnosticLocation ?? Location.None, propertyName, targetType.Name));
        }

        private static IEnumerable<ChangePropertyInfo> EnsureUniqueChangePropertyActions(IEnumerable<ChangePropertyInfo> infos)
        {
            foreach (var group in infos.GroupBy(info => (info.Namespace, info.ClassName)))
            {
                var distinct = group
                    .GroupBy(info => (info.TargetTypeName, info.PropertyName))
                    .Select(g => g.FirstOrDefault(info => info.Diagnostic is null) ?? g.First())
                    .ToList();

                if (distinct.Count == 1)
                {
                    yield return distinct[0];
                    continue;
                }

                foreach (var info in distinct)
                {
                    yield return info with { ClassName = MakeUniqueName(info.ClassName, info.TargetTypeName) };
                }
            }
        }

        private string GetChangePropertyAccessibility(INamedTypeSymbol targetType, IPropertySymbol propertySymbol)
        {
            var requiresInternal = targetType.DeclaredAccessibility == Accessibility.Internal ||
                                   propertySymbol.DeclaredAccessibility == Accessibility.Internal ||
                                   ContainsInternalType(propertySymbol.Type);

            return requiresInternal ? "internal" : "public";
        }
    }
}
