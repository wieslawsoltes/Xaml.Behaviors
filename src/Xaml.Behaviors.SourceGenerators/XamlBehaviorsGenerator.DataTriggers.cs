// Copyright (c) Wiesław Šoltés. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Xaml.Behaviors.SourceGenerators
{
    public partial class XamlBehaviorsGenerator
    {
        private record DataTriggerInfo(string Namespace, string ClassName, string Accessibility, string TypeName, Diagnostic? Diagnostic = null);

        private void RegisterDataTriggerGeneration(IncrementalGeneratorInitializationContext context)
        {
            var dataTriggers = context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: static (node, _) => IsPotentialDataTriggerAttribute(node),
                    transform: static (ctx, _) => GetDataTriggerFromAttributeSyntax(ctx))
                .Where(info => info is not null)
                .Select((info, _) => info!);

            var uniqueDataTriggers = dataTriggers
                .Collect()
                .SelectMany((infos, _) => EnsureUniqueDataTriggers(infos));

            context.RegisterSourceOutput(uniqueDataTriggers, ExecuteGenerateDataTrigger);
        }

        private static DataTriggerInfo? GetDataTriggerFromAttributeSyntax(GeneratorSyntaxContext context)
        {
            if (context.Node is not AttributeSyntax attributeSyntax)
                return null;

            var attributeType = context.SemanticModel.GetTypeInfo(attributeSyntax).Type
                ?? context.SemanticModel.GetAliasInfo(attributeSyntax.Name)?.Target as INamedTypeSymbol;

            if (attributeType == null && context.SemanticModel.GetSymbolInfo(attributeSyntax).Symbol is IMethodSymbol attributeCtor)
            {
                attributeType = attributeCtor.ContainingType;
            }

            var attributeName = attributeType?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            if (attributeName?.StartsWith("global::", StringComparison.Ordinal) == true)
            {
                attributeName = attributeName.Substring("global::".Length);
            }

            if (!string.Equals(attributeName, GenerateTypedDataTriggerAttributeName, StringComparison.Ordinal))
                return null;

            if (attributeSyntax.ArgumentList?.Arguments.Count != 1)
                return null;

            var typeOfExpression = attributeSyntax.ArgumentList.Arguments[0].Expression as TypeOfExpressionSyntax;
            if (typeOfExpression == null)
                return null;

            var typeInfo = context.SemanticModel.GetTypeInfo(typeOfExpression.Type).Type;
            const string namespaceName = "Xaml.Behaviors.Generated";
            var diagnosticLocation = attributeSyntax.GetLocation();

            if (typeInfo != null)
            {
                var validationDiagnostic = ValidateDataTriggerType(typeInfo, diagnosticLocation, context.SemanticModel.Compilation);
                var className = CreateDataTriggerClassName(typeInfo);
                var typeName = ToDisplayStringWithNullable(typeInfo);
                var accessibility = GetDataTriggerAccessibility(typeInfo);
                return new DataTriggerInfo(namespaceName, className, accessibility, typeName, validationDiagnostic);
            }

            var simpleName = typeOfExpression.Type switch
            {
                IdentifierNameSyntax id => id.Identifier.Text,
                QualifiedNameSyntax q => q.Right.Identifier.Text,
                _ => typeOfExpression.Type.ToString()
            };

            var fallbackName = CreateSafeIdentifier(simpleName);
            return new DataTriggerInfo(namespaceName, $"{fallbackName}DataTrigger", "public", typeOfExpression.Type.ToString());
        }

        private void ExecuteGenerateDataTrigger(SourceProductionContext spc, DataTriggerInfo info)
        {
            if (info.Diagnostic != null)
            {
                spc.ReportDiagnostic(info.Diagnostic);
                return;
            }

            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated />");
            sb.AppendLine("#nullable enable");
            sb.AppendLine("using System;");
            sb.AppendLine("using Avalonia;");
            sb.AppendLine("using Avalonia.Xaml.Interactivity;");
            sb.AppendLine("using Avalonia.Controls;");
            sb.AppendLine();
            sb.AppendLine($"namespace {info.Namespace}");
            sb.AppendLine("{");
            sb.AppendLine($"    {info.Accessibility} partial class {info.ClassName} : Avalonia.Xaml.Interactivity.StyledElementTrigger");
            sb.AppendLine("    {");
            sb.AppendLine($"        public static readonly StyledProperty<{info.TypeName}> BindingProperty =");
            sb.AppendLine($"            AvaloniaProperty.Register<{info.ClassName}, {info.TypeName}>(nameof(Binding));");
            sb.AppendLine();
            sb.AppendLine($"        public static readonly StyledProperty<ComparisonConditionType> ComparisonConditionProperty =");
            sb.AppendLine($"            AvaloniaProperty.Register<{info.ClassName}, ComparisonConditionType>(nameof(ComparisonCondition));");
            sb.AppendLine();
            sb.AppendLine($"        public static readonly StyledProperty<{info.TypeName}> ValueProperty =");
            sb.AppendLine($"            AvaloniaProperty.Register<{info.ClassName}, {info.TypeName}>(nameof(Value));");
            sb.AppendLine();
            sb.AppendLine($"        public {info.TypeName} Binding");
            sb.AppendLine("        {");
            sb.AppendLine("            get => GetValue(BindingProperty);");
            sb.AppendLine("            set => SetValue(BindingProperty, value);");
            sb.AppendLine("        }");
            sb.AppendLine();
            sb.AppendLine("        public ComparisonConditionType ComparisonCondition");
            sb.AppendLine("        {");
            sb.AppendLine("            get => GetValue(ComparisonConditionProperty);");
            sb.AppendLine("            set => SetValue(ComparisonConditionProperty, value);");
            sb.AppendLine("        }");
            sb.AppendLine();
            sb.AppendLine($"        public {info.TypeName} Value");
            sb.AppendLine("        {");
            sb.AppendLine("            get => GetValue(ValueProperty);");
            sb.AppendLine("            set => SetValue(ValueProperty, value);");
            sb.AppendLine("        }");
            sb.AppendLine();
            sb.AppendLine("        protected override void OnAttached()");
            sb.AppendLine("        {");
            sb.AppendLine("            base.OnAttached();");
            sb.AppendLine("            Evaluate();");
            sb.AppendLine("        }");
            sb.AppendLine();
            sb.AppendLine("        protected override void OnPropertyChanged(AvaloniaPropertyChangedEventArgs change)");
            sb.AppendLine("        {");
            sb.AppendLine("            base.OnPropertyChanged(change);");
            sb.AppendLine("            if (change.Property == BindingProperty || change.Property == ComparisonConditionProperty || change.Property == ValueProperty)");
            sb.AppendLine("            {");
            sb.AppendLine("                Evaluate();");
            sb.AppendLine("            }");
            sb.AppendLine("        }");
            sb.AppendLine();
            sb.AppendLine("        private void Evaluate()");
            sb.AppendLine("        {");
            sb.AppendLine("             bool result = false;");
            sb.AppendLine("             var left = Binding;");
            sb.AppendLine("             var right = Value;");
            sb.AppendLine("             switch (ComparisonCondition)");
            sb.AppendLine("             {");
            sb.AppendLine("                 case ComparisonConditionType.Equal: result = System.Collections.Generic.EqualityComparer<" + info.TypeName + ">.Default.Equals(left, right); break;");
            sb.AppendLine("                 case ComparisonConditionType.NotEqual: result = !System.Collections.Generic.EqualityComparer<" + info.TypeName + ">.Default.Equals(left, right); break;");
            sb.AppendLine();
            sb.AppendLine("                 default:");
            sb.AppendLine("                     var leftObj = (object?)left;");
            sb.AppendLine("                     if (leftObj is IComparable cmp)");
            sb.AppendLine("                     {");
            sb.AppendLine("                         var diff = cmp.CompareTo(right);");
            sb.AppendLine("                         switch (ComparisonCondition)");
            sb.AppendLine("                         {");
            sb.AppendLine("                             case ComparisonConditionType.LessThan: result = diff < 0; break;");
            sb.AppendLine("                             case ComparisonConditionType.LessThanOrEqual: result = diff <= 0; break;");
            sb.AppendLine("                             case ComparisonConditionType.GreaterThan: result = diff > 0; break;");
            sb.AppendLine("                             case ComparisonConditionType.GreaterThanOrEqual: result = diff >= 0; break;");
            sb.AppendLine("                         }");
            sb.AppendLine("                     }");
            var comparableType = TrimNullableAnnotation(info.TypeName);
            sb.AppendLine($"                     else if (leftObj is System.IComparable<{comparableType}> gcmp)");
            sb.AppendLine("                     {");
            sb.AppendLine("                         var diff = gcmp.CompareTo(right);");
            sb.AppendLine("                         switch (ComparisonCondition)");
            sb.AppendLine("                         {");
            sb.AppendLine("                             case ComparisonConditionType.LessThan: result = diff < 0; break;");
            sb.AppendLine("                             case ComparisonConditionType.LessThanOrEqual: result = diff <= 0; break;");
            sb.AppendLine("                             case ComparisonConditionType.GreaterThan: result = diff > 0; break;");
            sb.AppendLine("                             case ComparisonConditionType.GreaterThanOrEqual: result = diff >= 0; break;");
            sb.AppendLine("                         }");
            sb.AppendLine("                     }");
            sb.AppendLine("                     break;");
            sb.AppendLine("             }");
            sb.AppendLine();
            sb.AppendLine("             if (result)");
            sb.AppendLine("             {");
            sb.AppendLine("                 Interaction.ExecuteActions(AssociatedObject, Actions, null);");
            sb.AppendLine("             }");
            sb.AppendLine("        }");
            sb.AppendLine("    }");
            sb.AppendLine("}");

            spc.AddSource(CreateHintName(info.Namespace, info.ClassName), SourceText.From(sb.ToString(), Encoding.UTF8));
        }

        private static bool IsPotentialDataTriggerAttribute(SyntaxNode node)
        {
            return node is AttributeSyntax attribute &&
                   attribute.ArgumentList?.Arguments.Count == 1;
        }

        private static Diagnostic? ValidateDataTriggerType(ITypeSymbol typeSymbol, Location? diagnosticLocation, Compilation? compilation)
        {
            var location = diagnosticLocation ?? Location.None;

            if (typeSymbol is INamedTypeSymbol namedType)
            {
                var accessibility = ValidateTypeAccessibility(namedType, location, compilation);
                if (accessibility != null)
                {
                    return accessibility;
                }
            }

            if (ContainsTypeParameter(typeSymbol))
            {
                return Diagnostic.Create(GenericMemberNotSupportedDiagnostic, location, typeSymbol.ToDisplayString());
            }

            return null;
        }

        private static string CreateDataTriggerClassName(ITypeSymbol typeSymbol)
        {
            string baseName = typeSymbol switch
            {
                IArrayTypeSymbol array => CreateSafeIdentifier($"{array.ElementType.Name}Array{array.Rank}"),
                INamedTypeSymbol named => CreateSafeIdentifier(named.Name),
                _ => CreateSafeIdentifier(typeSymbol.Name ?? string.Empty)
            };

            if (string.IsNullOrEmpty(baseName))
            {
                var displayName = typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                var trimmed = displayName.StartsWith("global::", StringComparison.Ordinal) ? displayName.Substring("global::".Length) : displayName;
                baseName = CreateSafeIdentifier(trimmed);
            }

            if (string.IsNullOrEmpty(baseName))
            {
                baseName = "DataTrigger";
            }
            else if (char.IsLetter(baseName[0]))
            {
                baseName = char.ToUpperInvariant(baseName[0]) + baseName.Substring(1);
            }
            else
            {
                baseName = "_" + baseName;
            }

            return $"{baseName}DataTrigger";
        }

        private static IEnumerable<DataTriggerInfo> EnsureUniqueDataTriggers(IEnumerable<DataTriggerInfo> infos)
        {
            foreach (var group in infos.GroupBy(info => info.ClassName))
            {
                var distinct = group
                    .GroupBy(info => info.TypeName)
                    .Select(g => g.First())
                    .ToList();

                if (distinct.Count == 1)
                {
                    yield return distinct[0];
                    continue;
                }

                foreach (var info in distinct)
                {
                    yield return info with { ClassName = MakeUniqueName(info.ClassName, info.TypeName) };
                }
            }
        }

        private static string GetDataTriggerAccessibility(ITypeSymbol typeSymbol)
        {
            return ContainsInternalType(typeSymbol) ? "internal" : "public";
        }
    }
}
