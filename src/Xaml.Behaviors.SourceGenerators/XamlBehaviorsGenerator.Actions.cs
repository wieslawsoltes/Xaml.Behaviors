// Copyright (c) Wiesław Šoltés. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.

using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Xaml.Behaviors.SourceGenerators
{
    public partial class XamlBehaviorsGenerator
    {
        private record ActionParameter(string Name, string Type);

        private record ActionInfo(
            string? Namespace,
            string ClassName,
            string Accessibility,
            string TargetTypeName,
            string MethodName,
            ImmutableArray<ActionParameter> Parameters,
            bool IsAwaitable,
            bool IsValueTask,
            bool UseDispatcher,
            Diagnostic? Diagnostic = null);

        private void RegisterActionGeneration(IncrementalGeneratorInitializationContext context)
        {
            var actions = context.SyntaxProvider
                .ForAttributeWithMetadataName(
                    GenerateTypedActionAttributeName,
                    predicate: static (_, _) => true,
                    transform: (ctx, _) => GetActionToGenerate(ctx))
                .SelectMany((x, _) => x);

            var assemblyActions = context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: static (node, _) => IsAssemblyAttribute(node, "GenerateTypedAction"),
                    transform: (ctx, _) => GetAssemblyActionFromAttributeSyntax(ctx))
                .SelectMany((info, _) => info);

            var uniqueActions = actions
                .Collect()
                .Combine(assemblyActions.Collect())
                .SelectMany((data, _) => EnsureUniqueActions(data.Left.Concat(data.Right)));

            context.RegisterSourceOutput(uniqueActions, ExecuteGenerateAction);
        }

        private ImmutableArray<ActionInfo> GetActionToGenerate(GeneratorAttributeSyntaxContext context)
        {
            var results = ImmutableArray.CreateBuilder<ActionInfo>();
            var symbol = context.TargetSymbol;

            if (symbol is IAssemblySymbol)
            {
                return results.ToImmutable();
            }

            if (symbol is IMethodSymbol methodSymbol)
            {
                foreach (var attribute in context.Attributes)
                {
                    var useDispatcher = GetUseDispatcherFlag(attribute, context.SemanticModel);
                    var location = attribute.ApplicationSyntaxReference?.GetSyntax()?.GetLocation() ?? context.TargetNode?.GetLocation() ?? Location.None;
                    results.Add(CreateActionInfo(methodSymbol, location, context.SemanticModel.Compilation, useDispatcher: useDispatcher));
                }
            }

            return results.ToImmutable();
        }

        private bool IsAwaitableType(ITypeSymbol typeSymbol)
        {
            var typeName = ToDisplayStringWithNullable(typeSymbol);
            return typeName.StartsWith("global::System.Threading.Tasks.Task") ||
                   typeName.StartsWith("global::System.Threading.Tasks.ValueTask");
        }

        private bool IsValueTaskType(ITypeSymbol typeSymbol)
        {
            var typeName = ToDisplayStringWithNullable(typeSymbol);
            return typeName.StartsWith("global::System.Threading.Tasks.ValueTask");
        }

        private ImmutableArray<ActionInfo> GetAssemblyActions(Compilation compilation)
        {
            var results = ImmutableArray.CreateBuilder<ActionInfo>();
            foreach (var attributeData in compilation.Assembly.GetAttributes())
            {
                if (!IsAttribute(attributeData, GenerateTypedActionAttributeName)) continue;
                if (attributeData.ConstructorArguments.Length != 2) continue;

                var targetType = attributeData.ConstructorArguments[0].Value as INamedTypeSymbol;
                var methodName = attributeData.ConstructorArguments[1].Value as string;
                var useDispatcher = GetBoolNamedArgument(attributeData, "UseDispatcher");

                if (targetType == null || string.IsNullOrEmpty(methodName)) continue;

                results.AddRange(CreateActionInfos(targetType, methodName!, Location.None, includeTypeNamePrefix: true, compilation: compilation, useDispatcher: useDispatcher));
            }

            return results.ToImmutable();
        }

        private void ExecuteGenerateAction(SourceProductionContext spc, ActionInfo info)
        {
            if (info.Diagnostic != null)
            {
                spc.ReportDiagnostic(info.Diagnostic);
                return;
            }

            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated />");
            sb.AppendLine("#nullable enable");
            sb.AppendLine("using Avalonia;");
            sb.AppendLine("using Avalonia.Xaml.Interactivity;");
            sb.AppendLine("using Avalonia.Controls;");
            sb.AppendLine("using Avalonia.Threading;");
            sb.AppendLine();
            if (!string.IsNullOrEmpty(info.Namespace))
            {
                sb.AppendLine($"namespace {info.Namespace}");
                sb.AppendLine("{");
            }
            sb.AppendLine($"    {info.Accessibility} partial class {info.ClassName} : Avalonia.Xaml.Interactivity.StyledElementAction");
            sb.AppendLine("    {");
            sb.AppendLine($"        public static readonly StyledProperty<object?> TargetObjectProperty =");
            sb.AppendLine($"            AvaloniaProperty.Register<{info.ClassName}, object?>(nameof(TargetObject));");
            sb.AppendLine();
            sb.AppendLine("        public object? TargetObject");
            sb.AppendLine("        {");
            sb.AppendLine("            get => GetValue(TargetObjectProperty);");
            sb.AppendLine("            set => SetValue(TargetObjectProperty, value);");
            sb.AppendLine("        }");
            sb.AppendLine();

            bool isEventHandlerStyle = false;
            if (info.Parameters.Length == 2)
            {
                var p1Type = info.Parameters[0].Type;
                if (p1Type.Contains("System.Object") || p1Type.Contains("object"))
                {
                    isEventHandlerStyle = true;
                }
            }

            if (!isEventHandlerStyle)
            {
                foreach (var param in info.Parameters)
                {
                    var propName = char.ToUpper(param.Name[0]) + param.Name.Substring(1);
                    if (propName == "TargetObject") propName = "MethodParameter" + propName;

                    sb.AppendLine($"        public static readonly StyledProperty<{param.Type}> {propName}Property =");
                    sb.AppendLine($"            AvaloniaProperty.Register<{info.ClassName}, {param.Type}>(nameof({propName}));");
                    sb.AppendLine();
                    sb.AppendLine($"        public {param.Type} {propName}");
                    sb.AppendLine("        {");
                    sb.AppendLine($"            get => GetValue({propName}Property);");
                    sb.AppendLine($"            set => SetValue({propName}Property, value);");
                    sb.AppendLine("        }");
                    sb.AppendLine();
                }
            }

            if (info.IsAwaitable)
            {
                sb.AppendLine($"        public static readonly StyledProperty<bool> IsExecutingProperty =");
                sb.AppendLine($"            AvaloniaProperty.Register<{info.ClassName}, bool>(nameof(IsExecuting));");
                sb.AppendLine();
                sb.AppendLine("        public bool IsExecuting");
                sb.AppendLine("        {");
                sb.AppendLine("            get => GetValue(IsExecutingProperty);");
                sb.AppendLine("            private set => SetValue(IsExecutingProperty, value);");
                sb.AppendLine("        }");
                sb.AppendLine();
            }

            sb.AppendLine("        public override object Execute(object? sender, object? parameter)");
            sb.AppendLine("        {");
            sb.AppendLine("            var target = TargetObject ?? sender;");
            sb.AppendLine($"            if (target is {info.TargetTypeName} typedTarget)");
            sb.AppendLine("            {");

            string invocation;
            if (info.Parameters.Length == 0)
            {
                invocation = $"typedTarget.{info.MethodName}()";
            }
            else if (isEventHandlerStyle)
            {
                var p1Type = TrimNullableAnnotation(info.Parameters[0].Type);
                var p2Type = TrimNullableAnnotation(info.Parameters[1].Type);

                sb.AppendLine($"                var p1 = sender is {p1Type} s ? s : default;");
                sb.AppendLine($"                var p2 = parameter is {p2Type} p ? p : default;");
                invocation = $"typedTarget.{info.MethodName}(p1, p2)";
            }
            else
            {
                var args = new List<string>();
                foreach (var param in info.Parameters)
                {
                    var propName = char.ToUpper(param.Name[0]) + param.Name.Substring(1);
                    if (propName == "TargetObject") propName = "MethodParameter" + propName;
                    args.Add(propName);
                }
                invocation = $"typedTarget.{info.MethodName}({string.Join(", ", args)})";
            }

            if (info.IsAwaitable)
            {
                if (info.UseDispatcher)
                {
                    sb.AppendLine("                Avalonia.Threading.Dispatcher.UIThread.Post(async () =>");
                    sb.AppendLine("                {");
                    sb.AppendLine($"                    var task = {invocation};");
                    if (info.IsValueTask)
                    {
                        sb.AppendLine("                    var t = task.AsTask();");
                    }
                    else
                    {
                        sb.AppendLine("                    var t = task;");
                    }
                    sb.AppendLine("                    TrackTask(t);");
                    sb.AppendLine("                });");
                    sb.AppendLine("                return true;");
                }
                else
                {
                    sb.AppendLine($"                var task = {invocation};");
                    if (info.IsValueTask)
                    {
                        sb.AppendLine("                var t = task.AsTask();");
                    }
                    else
                    {
                        sb.AppendLine("                var t = task;");
                    }
                    sb.AppendLine("                return TrackTask(t);");
                }
            }
            else
            {
                if (info.UseDispatcher)
                {
                    sb.AppendLine($"                Avalonia.Threading.Dispatcher.UIThread.Post(() => {invocation});");
                    sb.AppendLine("                return true;");
                }
                else
                {
                    sb.AppendLine($"                {invocation};");
                    sb.AppendLine("                return true;");
                }
            }

            sb.AppendLine("            }");
            sb.AppendLine("            return false;");
            sb.AppendLine("        }");
            if (info.IsAwaitable)
            {
                sb.AppendLine();
                sb.AppendLine("        private bool TrackTask(System.Threading.Tasks.Task? task)");
                sb.AppendLine("        {");
                sb.AppendLine("            if (task == null)");
                sb.AppendLine("            {");
                sb.AppendLine("                return true;");
                sb.AppendLine("            }");
                sb.AppendLine();
                sb.AppendLine("            if (task.IsCompleted)");
                sb.AppendLine("            {");
                sb.AppendLine("                ObserveCompletedTask(task);");
                sb.AppendLine("                return true;");
                sb.AppendLine("            }");
                sb.AppendLine();
                sb.AppendLine("            IsExecuting = true;");
                sb.AppendLine("            _ = ObserveTaskAsync(task);");
                sb.AppendLine("            return true;");
                sb.AppendLine("        }");
                sb.AppendLine();
                sb.AppendLine("        private void ObserveCompletedTask(System.Threading.Tasks.Task task)");
                sb.AppendLine("        {");
                sb.AppendLine("            if (task.IsFaulted)");
                sb.AppendLine("            {");
                sb.AppendLine("                if (task.Exception is not null)");
                sb.AppendLine("                {");
                sb.AppendLine("                    throw task.Exception;");
                sb.AppendLine("                }");
                sb.AppendLine("                throw new System.InvalidOperationException(\"Action task faulted.\");");
                sb.AppendLine("            }");
                sb.AppendLine();
                sb.AppendLine("            if (task.IsCanceled)");
                sb.AppendLine("            {");
                sb.AppendLine("                throw new System.OperationCanceledException(\"Action task was canceled.\");");
                sb.AppendLine("            }");
                sb.AppendLine();
                sb.AppendLine("            IsExecuting = false;");
                sb.AppendLine("        }");
                sb.AppendLine();
                sb.AppendLine("        private async System.Threading.Tasks.Task ObserveTaskAsync(System.Threading.Tasks.Task task)");
                sb.AppendLine("        {");
                sb.AppendLine("            try");
                sb.AppendLine("            {");
                sb.AppendLine("                await task.ConfigureAwait(false);");
                sb.AppendLine("            }");
                sb.AppendLine("            catch (System.Exception ex)");
                sb.AppendLine("            {");
                sb.AppendLine("                Avalonia.Threading.Dispatcher.UIThread.Post(() => throw new System.InvalidOperationException(\"Action task faulted.\", ex));");
                sb.AppendLine("            }");
                sb.AppendLine("            finally");
                sb.AppendLine("            {");
                sb.AppendLine("                Avalonia.Threading.Dispatcher.UIThread.Post(() => IsExecuting = false);");
                sb.AppendLine("            }");
                sb.AppendLine("        }");
            }
            sb.AppendLine("    }");
            if (!string.IsNullOrEmpty(info.Namespace))
            {
                sb.AppendLine("}");
            }

            spc.AddSource(CreateHintName(info.Namespace, info.ClassName), SourceText.From(sb.ToString(), Encoding.UTF8));
        }

        private (IMethodSymbol? Method, Diagnostic? Diagnostic) ResolveMethod(INamedTypeSymbol targetType, string name)
        {
            var current = targetType;
            while (current != null)
            {
                var methods = current
                    .GetMembers()
                    .OfType<IMethodSymbol>()
                    .Where(m => m.MethodKind == MethodKind.Ordinary && m.Name == name)
                    .ToList();

                if (methods.Count == 1)
                {
                    return (methods[0], null);
                }

                if (methods.Count > 1)
                {
                    return (null, Diagnostic.Create(ActionMethodAmbiguousDiagnostic, Location.None, name, targetType.Name));
                }

                current = current.BaseType;
            }

            return (null, Diagnostic.Create(ActionMethodNotFoundDiagnostic, Location.None, name, targetType.Name));
        }

        private static Diagnostic? ValidateActionMethod(IMethodSymbol methodSymbol, Location? diagnosticLocation, Compilation? compilation)
        {
            var location = diagnosticLocation ?? Location.None;

            if (methodSymbol.IsStatic)
            {
                return Diagnostic.Create(StaticMemberNotSupportedDiagnostic, location, methodSymbol.Name);
            }

            var containingTypeDiagnostic = ValidateTypeAccessibility(methodSymbol.ContainingType, location, compilation);
            if (containingTypeDiagnostic != null)
            {
                return containingTypeDiagnostic;
            }

            if (!IsAccessibleToGenerator(methodSymbol, compilation))
            {
                return Diagnostic.Create(MemberNotAccessibleDiagnostic, location, methodSymbol.Name, methodSymbol.ContainingType.ToDisplayString());
            }

            if (methodSymbol.IsGenericMethod ||
                ContainsTypeParameter(methodSymbol.ContainingType) ||
                ContainsTypeParameter(methodSymbol.ReturnType) ||
                methodSymbol.Parameters.Any(p => ContainsTypeParameter(p.Type)))
            {
                return Diagnostic.Create(GenericMemberNotSupportedDiagnostic, location, methodSymbol.Name);
            }

            var unsupportedParameter = methodSymbol.Parameters.FirstOrDefault(p => p.RefKind != RefKind.None);
            if (unsupportedParameter != null)
            {
                return Diagnostic.Create(ActionParameterModifierNotSupportedDiagnostic, location, methodSymbol.Name, unsupportedParameter.Name, FormatRefKindKeyword(unsupportedParameter.RefKind));
            }

            if (!IsAccessibleType(methodSymbol.ReturnType, compilation) ||
                methodSymbol.Parameters.Any(p => !IsAccessibleType(p.Type, compilation)))
            {
                return Diagnostic.Create(MemberNotAccessibleDiagnostic, location, methodSymbol.Name, methodSymbol.ContainingType.ToDisplayString());
            }

            return null;
        }

        private ImmutableArray<ActionInfo> GetAssemblyActionFromAttributeSyntax(GeneratorSyntaxContext context)
        {
            if (context.Node is not AttributeSyntax attributeSyntax)
                return ImmutableArray<ActionInfo>.Empty;

            if (attributeSyntax.ArgumentList?.Arguments == null)
                return ImmutableArray<ActionInfo>.Empty;

            var positionalArguments = attributeSyntax.ArgumentList.Arguments
                .Where(a => a.NameEquals is null && a.NameColon is null)
                .ToList();

            if (positionalArguments.Count < 2)
                return ImmutableArray<ActionInfo>.Empty;

            if (positionalArguments[0].Expression is not TypeOfExpressionSyntax typeOfExpression)
                return ImmutableArray<ActionInfo>.Empty;

            if (positionalArguments[1].Expression is not LiteralExpressionSyntax methodLiteral)
                return ImmutableArray<ActionInfo>.Empty;

            var methodName = methodLiteral.Token.ValueText;
            var targetType = context.SemanticModel.GetTypeInfo(typeOfExpression.Type).Type as INamedTypeSymbol;
            if (targetType == null || string.IsNullOrEmpty(methodName))
                return ImmutableArray<ActionInfo>.Empty;

            var useDispatcher = GetBoolNamedArgument(attributeSyntax, context.SemanticModel, "UseDispatcher");

            return CreateActionInfos(targetType, methodName, context.Node.GetLocation(), includeTypeNamePrefix: true, compilation: context.SemanticModel.Compilation, useDispatcher: useDispatcher);
        }

        private ActionInfo CreateActionInfo(IMethodSymbol methodSymbol, Location? diagnosticLocation, Compilation? compilation, bool includeTypeNamePrefix = false, bool useDispatcher = false)
        {
            var targetType = methodSymbol.ContainingType;
            if (targetType == null)
            {
                var className = $"{methodSymbol.Name}Action";
                return new ActionInfo(null, className, "public", "", methodSymbol.Name, ImmutableArray<ActionParameter>.Empty, false, false, useDispatcher, Diagnostic.Create(ActionMethodNotFoundDiagnostic, diagnosticLocation ?? Location.None, methodSymbol.Name, "<unknown>"));
            }

            return CreateActionInfo(targetType, methodSymbol, diagnosticLocation, includeTypeNamePrefix, compilation, useDispatcher);
        }

        private ImmutableArray<ActionInfo> CreateActionInfos(INamedTypeSymbol targetType, string methodPattern, Location? diagnosticLocation = null, bool includeTypeNamePrefix = false, Compilation? compilation = null, bool useDispatcher = false)
        {
            var allMatches = FindMatchingMethods(targetType, methodPattern, requirePublicAccessibility: false, requireAccessibleTypes: false, compilation: compilation);
            var matchedMethods = FindMatchingMethods(targetType, methodPattern, compilation: compilation);
            var typePrefix = includeTypeNamePrefix ? GetTypeNamePrefix(targetType) : string.Empty;
            var classPrefix = string.IsNullOrEmpty(typePrefix) ? string.Empty : typePrefix;
            var isPattern = methodPattern.Contains("*") ||
                            methodPattern.IndexOfAny(new[] { '.', '$', '^', '[', ']', '(', ')', '+', '?', '{', '}', '|', '\\' }) >= 0;
            var hasAnyMatch = allMatches.Length > 0;
            if (matchedMethods.Length == 0)
            {
                var diagnostic = Diagnostic.Create(
                    hasAnyMatch ? MemberNotAccessibleDiagnostic : ActionMethodNotFoundDiagnostic,
                    diagnosticLocation ?? Location.None,
                    methodPattern,
                    targetType.Name);
                var ns = targetType.ContainingNamespace.ToDisplayString();
                var namespaceName = (targetType.ContainingNamespace.IsGlobalNamespace || ns == "<global namespace>") ? null : ns;
                var baseName = $"{CreateSafeIdentifier(methodPattern)}Action";
                var className = string.IsNullOrEmpty(classPrefix) ? baseName : classPrefix + baseName;
                var targetTypeName = ToDisplayStringWithNullable(targetType);
                var accessibility = GetActionAccessibility(targetType);
                return ImmutableArray.Create(new ActionInfo(namespaceName, className, accessibility, targetTypeName, methodPattern, ImmutableArray<ActionParameter>.Empty, false, false, useDispatcher, diagnostic));
            }

            var nsPart = targetType.ContainingNamespace.ToDisplayString();
            var namespaceNamePart = (targetType.ContainingNamespace.IsGlobalNamespace || nsPart == "<global namespace>") ? null : nsPart;
            var targetTypeNamePart = ToDisplayStringWithNullable(targetType);
            var accessibleMethods = matchedMethods
                .Where(m => UsesAccessibleTypes(m, compilation))
                .Where(m => ValidateActionMethod(m, diagnosticLocation, compilation) is null)
                .ToList();

            if (accessibleMethods.Count == 0)
            {
                var diag = Diagnostic.Create(
                    hasAnyMatch ? MemberNotAccessibleDiagnostic : ActionMethodNotFoundDiagnostic,
                    diagnosticLocation ?? Location.None,
                    methodPattern,
                    targetType.ToDisplayString());
                var fallbackBase = $"{CreateSafeIdentifier(methodPattern)}Action";
                var fallbackClassName = string.IsNullOrEmpty(classPrefix) ? fallbackBase : classPrefix + fallbackBase;
                var accessibility = GetActionAccessibility(targetType);
                return ImmutableArray.Create(new ActionInfo(namespaceNamePart, fallbackClassName, accessibility, targetTypeNamePart, methodPattern, ImmutableArray<ActionParameter>.Empty, false, false, useDispatcher, diag));
            }

            var builder = ImmutableArray.CreateBuilder<ActionInfo>();

            foreach (var group in accessibleMethods.GroupBy(m => m.Name))
            {
                if (group.Skip(1).Any())
                {
                    if (!isPattern)
                    {
                        var diagnostic = Diagnostic.Create(ActionMethodAmbiguousDiagnostic, diagnosticLocation ?? Location.None, group.Key, targetType.Name);
                        var baseName = $"{group.Key}Action";
                        var className = string.IsNullOrEmpty(classPrefix) ? baseName : classPrefix + baseName;
                        var accessibility = GetActionAccessibility(targetType, group.First());
                        builder.Add(new ActionInfo(namespaceNamePart, className, accessibility, targetTypeNamePart, group.Key, ImmutableArray<ActionParameter>.Empty, false, false, useDispatcher, diagnostic));
                    }
                    continue;
                }

                builder.Add(CreateActionInfo(targetType, group.First(), diagnosticLocation, includeTypeNamePrefix, compilation, useDispatcher));
            }

            return builder.ToImmutable();
        }

        private ActionInfo CreateActionInfo(INamedTypeSymbol targetType, string methodName, Location? diagnosticLocation = null, Compilation? compilation = null, bool useDispatcher = false)
        {
            var infos = CreateActionInfos(targetType, methodName, diagnosticLocation, compilation: compilation, useDispatcher: useDispatcher);
            var accessibility = GetActionAccessibility(targetType);
            return infos.Length > 0 ? infos[0] : new ActionInfo(null, $"{methodName}Action", accessibility, ToDisplayStringWithNullable(targetType), methodName, ImmutableArray<ActionParameter>.Empty, false, false, useDispatcher, Diagnostic.Create(ActionMethodNotFoundDiagnostic, diagnosticLocation ?? Location.None, methodName, targetType.Name));
        }

        private ActionInfo CreateActionInfo(INamedTypeSymbol targetType, IMethodSymbol methodSymbol, Location? diagnosticLocation = null, bool includeTypeNamePrefix = false, Compilation? compilation = null, bool useDispatcher = false)
        {
            var ns = targetType.ContainingNamespace.ToDisplayString();
            var namespaceName = (targetType.ContainingNamespace.IsGlobalNamespace || ns == "<global namespace>") ? null : ns;
            var baseName = $"{methodSymbol.Name}Action";
            var typePrefix = includeTypeNamePrefix ? GetTypeNamePrefix(targetType) : string.Empty;
            var className = string.IsNullOrEmpty(typePrefix) ? baseName : typePrefix + baseName;
            var targetTypeName = ToDisplayStringWithNullable(targetType);
            var accessibility = GetActionAccessibility(targetType, methodSymbol);

            var validationDiagnostic = ValidateActionMethod(methodSymbol, diagnosticLocation, compilation);
            if (validationDiagnostic != null)
            {
                return new ActionInfo(namespaceName, className, accessibility, targetTypeName, methodSymbol.Name, ImmutableArray<ActionParameter>.Empty, false, false, useDispatcher, validationDiagnostic);
            }

            if (!IsAccessibleType(methodSymbol.ReturnType, compilation) || methodSymbol.Parameters.Any(p => !IsAccessibleType(p.Type, compilation)))
            {
                var diag = Diagnostic.Create(MemberNotAccessibleDiagnostic, diagnosticLocation ?? Location.None, methodSymbol.Name, methodSymbol.ContainingType.ToDisplayString());
                return new ActionInfo(namespaceName, className, accessibility, targetTypeName, methodSymbol.Name, ImmutableArray<ActionParameter>.Empty, false, false, useDispatcher, diag);
            }

            var parameters = methodSymbol.Parameters.Select(p => new ActionParameter(p.Name, ToDisplayStringWithNullable(p.Type))).ToImmutableArray();

            var returnType = methodSymbol.ReturnType;
            bool isAwaitable = IsAwaitableType(returnType);
            bool isValueTask = IsValueTaskType(returnType);

            return new ActionInfo(namespaceName, className, accessibility, targetTypeName, methodSymbol.Name, parameters, isAwaitable, isValueTask, useDispatcher);
        }

        private bool UsesAccessibleTypes(IMethodSymbol methodSymbol, Compilation? compilation)
        {
            return IsAccessibleType(methodSymbol.ReturnType, compilation) && methodSymbol.Parameters.All(p => IsAccessibleType(p.Type, compilation));
        }

        private string GetActionAccessibility(INamedTypeSymbol targetType, IMethodSymbol? methodSymbol = null)
        {
            var requiresInternal = targetType.DeclaredAccessibility == Accessibility.Internal;

            if (methodSymbol != null)
            {
                requiresInternal |= methodSymbol.DeclaredAccessibility == Accessibility.Internal;
                requiresInternal |= ContainsInternalType(methodSymbol.ReturnType);
                requiresInternal |= methodSymbol.Parameters.Any(p => ContainsInternalType(p.Type));
            }

            return requiresInternal ? "internal" : "public";
        }

        private static IMethodSymbol? SelectBestOverload(IEnumerable<IMethodSymbol> methods)
        {
            var list = methods.ToList();
            if (list.Count == 0) return null;

            var ordered = list
                .OrderByDescending(m => GetInheritanceDepth(m.ContainingType))
                .ThenBy(m => m.Parameters.Length)
                .ThenBy(m => m.Parameters.Select(p => p.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)).Aggregate(0, (a, b) => a + b.Length))
                .ToList();

            var best = ordered[0];
            var bestKey = CreateMethodSignatureKey(best) + "|" + GetInheritanceDepth(best.ContainingType);
            var tie = ordered.Skip(1).Any(m => (CreateMethodSignatureKey(m) + "|" + GetInheritanceDepth(m.ContainingType)) == bestKey);
            return tie ? null : best;
        }

        private static int GetInheritanceDepth(INamedTypeSymbol? type)
        {
            var depth = 0;
            var current = type;
            while (current != null)
            {
                depth++;
                current = current.BaseType;
            }
            return depth;
        }

        private static IEnumerable<ActionInfo> EnsureUniqueActions(IEnumerable<ActionInfo> infos)
        {
            foreach (var group in infos.GroupBy(info => (info.Namespace, info.ClassName)))
            {
                var distinct = group
                    .GroupBy(info => (info.TargetTypeName, info.MethodName))
                    .Select(g => g.FirstOrDefault(info => info.Diagnostic is null) ?? g.First())
                    .ToList();

                if (distinct.Count == 1)
                {
                    yield return distinct[0];
                    continue;
                }

                foreach (var info in distinct)
                {
                    yield return info with { ClassName = MakeUniqueName(info.ClassName, info.TargetTypeName) };
                }
            }
        }
    }
}
