using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Avalonia.Xaml.Interactions.Generators;

[Generator]
public sealed class EventTriggerSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var events = context.CompilationProvider.SelectMany((comp, ct) => GetEvents(comp));
        var collected = events.Collect();
        context.RegisterSourceOutput(collected, (spc, events) => Generate(spc, events));
    }

    private static IEnumerable<(INamedTypeSymbol Type, IEventSymbol Event)> GetEvents(Compilation compilation)
    {
        foreach (var tree in compilation.SyntaxTrees)
        {
            var semanticModel = compilation.GetSemanticModel(tree);
            var root = tree.GetRoot();
            foreach (var typeDecl in root.DescendantNodes().OfType<TypeDeclarationSyntax>())
            {
                var symbol = semanticModel.GetDeclaredSymbol(typeDecl) as INamedTypeSymbol;
                if (symbol is null)
                    continue;
                foreach (var ev in symbol.GetMembers().OfType<IEventSymbol>())
                {
                    yield return (symbol, ev);
                }
            }
        }
    }

    private static void Generate(SourceProductionContext context, IEnumerable<(INamedTypeSymbol Type, IEventSymbol Event)> events)
    {
        var groups = events.GroupBy(e => e.Type, SymbolEqualityComparer.Default);
        var sb = new System.Text.StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("using System;");
        sb.AppendLine("namespace Avalonia.Xaml.Interactions.Core");
        sb.AppendLine("{");
        sb.AppendLine("    public partial class EventTriggerBehavior");
        sb.AppendLine("    {");
        sb.AppendLine("        partial bool TryAddGeneratedHandler(object source, string eventName, out Action? unregister)");
        sb.AppendLine("        {");
        sb.AppendLine("            unregister = null;");
        sb.AppendLine("            switch (eventName)");
        sb.AppendLine("        {");
        foreach (var group in groups)
        {
            var type = group.Key;
            var typeName = type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            foreach (var ev in group)
            {
                var eventName = ev.Event.Name;
                var delegateType = ev.Event.Type as INamedTypeSymbol;
                var invoke = delegateType?.DelegateInvokeMethod;
                if (invoke is null)
                    continue;
                var parameters = string.Join(", ", invoke.Parameters.Select(p => p.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) + " " + p.Name));
                var args = string.Join(", ", invoke.Parameters.Select(p => p.Name));
                sb.AppendLine($"            case \"{eventName}\" when source is {typeName} typed{eventName}:");
                sb.AppendLine($"                void handler_{type.Name}_{eventName}({parameters}) => Execute({invoke.Parameters.Last().Name});");
                sb.AppendLine($"                typed{eventName}.{eventName} += handler_{type.Name}_{eventName};");
                sb.AppendLine($"                unregister = () => typed{eventName}.{eventName} -= handler_{type.Name}_{eventName};");
                sb.AppendLine($"                return true;");
            }
        }
        sb.AppendLine("            default:");
        sb.AppendLine("                return false;");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine("}");
        context.AddSource("EventTriggerBehavior.Generated.cs", sb.ToString());
    }
}
